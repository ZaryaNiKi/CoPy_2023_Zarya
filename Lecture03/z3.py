maze = [
    [' ', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
    [' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#'],
    ['#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#', '#', '#', ' ', '#', '#', '#', ' ', '#'],
    ['#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#'],
    ['#', '#', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#', '#', '#', ' ', '#'],
    ['#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'],
    ['#', ' ', '#', '#', '#', '#', '#', ' ', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'],
    ['#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#'],
    ['#', ' ', '#', ' ', '#', '#', '#', ' ', '#', '#', '#', ' ', '#', '#', '#', ' ', '#', '#', '#', ' ', '#'],
    ['#', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'],
    ['#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#', '#', '#'],
    ['#', ' ', '#', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'],
    ['#', ' ', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', '#'],
    ['#', ' ', ' ', ' ', '#', ' ', '#', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#'],
    ['#', '#', '#', '#', '#', ' ', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', ' ', '#', '#', '#', '#', '#'],
    ['#', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', '#'],
    ['#', ' ', '#', ' ', '#', ' ', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', ' ', '#'],
    ['#', ' ', '#', ' ', '#', ' ', ' ', ' ', '#', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#'],
    ['#', ' ', '#', ' ', '#', '#', '#', '#', '#', ' ', '#', ' ', '#', '#', '#', ' ', '#', ' ', '#', '#', '#'],
    ['#', ' ', '#', ' ', ' ', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', '#', ' ', ' ', ' ', ' '],
    ['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', ' ', ' '],
]
x_Exit_1 = 0; y_Exit_1 = 0 ##Это можно найти и самим, однако для конкретики напишу, что понимяаю по2д точками выхода.
x_Exit_2 = 20; y_Exit_2 = 20
#Создадим function, которая по точке выхода, рассчитывает растояния всех путей лабиринта. 
def function(x_start, y_start):
    # Создание списка расстояний
    distances =  [[0 for jjj in range(len(maze))] for iii in range(len(maze))]
    #Словарь растояний для точки
    queue = {(x_start, y_start): 0}
    #Штуки от которых алгоритм заканчиваеться
    last_queue = []
    possible_queue = [(x_start, y_start)]

    #Предварительно получим все кординаты проходов
    cor = []
    for iii in range(len(maze)):
            for jjj in range(len(maze[iii])):
                if maze[jjj][iii] == ' ':
                  cor.append((iii, jjj))
    #Идея: Выбранная клетка ищет соседние, и увеличивает растояние на 1.
    while len(set(cor) - set(last_queue)):
          unique_element = possible_queue[0]
          x, y = unique_element
          # Перебор соседних клеток
          for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
              if 0 <= x + dx <= len(maze)-1 and 0 <= y + dy <= len(maze)-1: #Нужно чтобы не зайти за границы
                nx, ny = x + dx, y + dy
                if (x, y) in possible_queue or neighbor_counts == 1: #Нужно чтобы цыкл закончился
                    last_queue.append((x, y))
                    possible_queue = list(set(possible_queue)-set(last_queue))
                if  (maze[ny][nx] == ' ') and (nx, ny) != (x, y) and (nx, ny) not in last_queue : #Нужно чтобы словарь растояний заполнялся.
                    possible_queue.append((nx, ny))
                    distances[ny][nx] = distances[y][x] + 1
                    queue[(nx, ny)] = distances[ny][nx]
    return queue 

while True:
    try:
        x_start = int(input("Введите координату x (начальная позиция, нумерация с 0): "))
        y_start = int(input("Введите координату y (начальная позиция, нумерация с 0): "))
        if 0 <= x_start < len(maze[0]) and 0 <= y_start < len(maze) and (maze[x_start][y_start] == ' '):
            print(f'Наименьшее растояние до выхода: {min([function(x_Exit_1, y_Exit_1)[x_start,y_start], function(x_Exit_2, y_Exit_2)[x_start,y_start]])}')
            maze[y_start][x_start] = "++"
            xi, yi = 0, 0
            while yi < len(maze):
                print("".join(maze[yi]).replace("#", "██").replace(" ", "  "))
                yi += 1
            break
        else:
            print("Некорректные координаты. Пожалуйста, введите корректные координаты.")
    except ValueError:
        print("Некорректный ввод. Пожалуйста, введите целые числа.")